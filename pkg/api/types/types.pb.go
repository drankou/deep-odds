// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/api/types/types.proto

package types

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type InPlayEventsRequest struct {
	//league id
	LeagueId             string   `protobuf:"bytes,2,opt,name=league_id,json=leagueId,proto3" json:"league_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InPlayEventsRequest) Reset()         { *m = InPlayEventsRequest{} }
func (m *InPlayEventsRequest) String() string { return proto.CompactTextString(m) }
func (*InPlayEventsRequest) ProtoMessage()    {}
func (*InPlayEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ac661acc13075b, []int{0}
}
func (m *InPlayEventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InPlayEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InPlayEventsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InPlayEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InPlayEventsRequest.Merge(m, src)
}
func (m *InPlayEventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *InPlayEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InPlayEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InPlayEventsRequest proto.InternalMessageInfo

func (m *InPlayEventsRequest) GetLeagueId() string {
	if m != nil {
		return m.LeagueId
	}
	return ""
}

type EventsResponse struct {
	Events               []*Event `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventsResponse) Reset()         { *m = EventsResponse{} }
func (m *EventsResponse) String() string { return proto.CompactTextString(m) }
func (*EventsResponse) ProtoMessage()    {}
func (*EventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ac661acc13075b, []int{1}
}
func (m *EventsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventsResponse.Merge(m, src)
}
func (m *EventsResponse) XXX_Size() int {
	return m.Size()
}
func (m *EventsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EventsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EventsResponse proto.InternalMessageInfo

func (m *EventsResponse) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

type EventPredictionRequest struct {
	EventId              string   `protobuf:"bytes,1,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventPredictionRequest) Reset()         { *m = EventPredictionRequest{} }
func (m *EventPredictionRequest) String() string { return proto.CompactTextString(m) }
func (*EventPredictionRequest) ProtoMessage()    {}
func (*EventPredictionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ac661acc13075b, []int{2}
}
func (m *EventPredictionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPredictionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPredictionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPredictionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPredictionRequest.Merge(m, src)
}
func (m *EventPredictionRequest) XXX_Size() int {
	return m.Size()
}
func (m *EventPredictionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPredictionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EventPredictionRequest proto.InternalMessageInfo

func (m *EventPredictionRequest) GetEventId() string {
	if m != nil {
		return m.EventId
	}
	return ""
}

type PredictionResponse struct {
	Prediction           *Prediction `protobuf:"bytes,1,opt,name=prediction,proto3" json:"prediction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PredictionResponse) Reset()         { *m = PredictionResponse{} }
func (m *PredictionResponse) String() string { return proto.CompactTextString(m) }
func (*PredictionResponse) ProtoMessage()    {}
func (*PredictionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ac661acc13075b, []int{3}
}
func (m *PredictionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredictionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredictionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredictionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredictionResponse.Merge(m, src)
}
func (m *PredictionResponse) XXX_Size() int {
	return m.Size()
}
func (m *PredictionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PredictionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PredictionResponse proto.InternalMessageInfo

func (m *PredictionResponse) GetPrediction() *Prediction {
	if m != nil {
		return m.Prediction
	}
	return nil
}

type Prediction struct {
	HomeWin              float64  `protobuf:"fixed64,1,opt,name=home_win,json=homeWin,proto3" json:"home_win,omitempty"`
	Draw                 float64  `protobuf:"fixed64,2,opt,name=draw,proto3" json:"draw,omitempty"`
	AwayWin              float64  `protobuf:"fixed64,3,opt,name=away_win,json=awayWin,proto3" json:"away_win,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Prediction) Reset()         { *m = Prediction{} }
func (m *Prediction) String() string { return proto.CompactTextString(m) }
func (*Prediction) ProtoMessage()    {}
func (*Prediction) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ac661acc13075b, []int{4}
}
func (m *Prediction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prediction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prediction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prediction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prediction.Merge(m, src)
}
func (m *Prediction) XXX_Size() int {
	return m.Size()
}
func (m *Prediction) XXX_DiscardUnknown() {
	xxx_messageInfo_Prediction.DiscardUnknown(m)
}

var xxx_messageInfo_Prediction proto.InternalMessageInfo

func (m *Prediction) GetHomeWin() float64 {
	if m != nil {
		return m.HomeWin
	}
	return 0
}

func (m *Prediction) GetDraw() float64 {
	if m != nil {
		return m.Draw
	}
	return 0
}

func (m *Prediction) GetAwayWin() float64 {
	if m != nil {
		return m.AwayWin
	}
	return 0
}

type Event struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TimeStatus           string   `protobuf:"bytes,2,opt,name=time_status,json=timeStatus,proto3" json:"time_status,omitempty"`
	Score                string   `protobuf:"bytes,3,opt,name=score,proto3" json:"score,omitempty"`
	HomeTeam             string   `protobuf:"bytes,4,opt,name=home_team,json=homeTeam,proto3" json:"home_team,omitempty"`
	AwayTeam             string   `protobuf:"bytes,5,opt,name=away_team,json=awayTeam,proto3" json:"away_team,omitempty"`
	LeagueName           string   `protobuf:"bytes,6,opt,name=league_name,json=leagueName,proto3" json:"league_name,omitempty"`
	Timer                *Timer   `protobuf:"bytes,7,opt,name=timer,proto3" json:"timer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ac661acc13075b, []int{5}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Event) GetTimeStatus() string {
	if m != nil {
		return m.TimeStatus
	}
	return ""
}

func (m *Event) GetScore() string {
	if m != nil {
		return m.Score
	}
	return ""
}

func (m *Event) GetHomeTeam() string {
	if m != nil {
		return m.HomeTeam
	}
	return ""
}

func (m *Event) GetAwayTeam() string {
	if m != nil {
		return m.AwayTeam
	}
	return ""
}

func (m *Event) GetLeagueName() string {
	if m != nil {
		return m.LeagueName
	}
	return ""
}

func (m *Event) GetTimer() *Timer {
	if m != nil {
		return m.Timer
	}
	return nil
}

type Timer struct {
	Minutes              int64    `protobuf:"varint,1,opt,name=minutes,proto3" json:"minutes,omitempty"`
	Seconds              int64    `protobuf:"varint,2,opt,name=seconds,proto3" json:"seconds,omitempty"`
	AddedTime            int64    `protobuf:"varint,3,opt,name=added_time,json=addedTime,proto3" json:"added_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Timer) Reset()         { *m = Timer{} }
func (m *Timer) String() string { return proto.CompactTextString(m) }
func (*Timer) ProtoMessage()    {}
func (*Timer) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ac661acc13075b, []int{6}
}
func (m *Timer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timer.Merge(m, src)
}
func (m *Timer) XXX_Size() int {
	return m.Size()
}
func (m *Timer) XXX_DiscardUnknown() {
	xxx_messageInfo_Timer.DiscardUnknown(m)
}

var xxx_messageInfo_Timer proto.InternalMessageInfo

func (m *Timer) GetMinutes() int64 {
	if m != nil {
		return m.Minutes
	}
	return 0
}

func (m *Timer) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timer) GetAddedTime() int64 {
	if m != nil {
		return m.AddedTime
	}
	return 0
}

func init() {
	proto.RegisterType((*InPlayEventsRequest)(nil), "InPlayEventsRequest")
	proto.RegisterType((*EventsResponse)(nil), "EventsResponse")
	proto.RegisterType((*EventPredictionRequest)(nil), "EventPredictionRequest")
	proto.RegisterType((*PredictionResponse)(nil), "PredictionResponse")
	proto.RegisterType((*Prediction)(nil), "Prediction")
	proto.RegisterType((*Event)(nil), "Event")
	proto.RegisterType((*Timer)(nil), "Timer")
}

func init() { proto.RegisterFile("pkg/api/types/types.proto", fileDescriptor_59ac661acc13075b) }

var fileDescriptor_59ac661acc13075b = []byte{
	// 522 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0x6e, 0xda, 0xf5, 0xef, 0x54, 0x1a, 0x92, 0x37, 0xb1, 0xac, 0x40, 0x37, 0xe5, 0x6a, 0x12,
	0x5a, 0x82, 0xba, 0x07, 0x40, 0x4c, 0xc0, 0x54, 0x09, 0xc1, 0x14, 0x26, 0x26, 0xed, 0xa6, 0x72,
	0xeb, 0x43, 0x67, 0xad, 0xb1, 0x43, 0xec, 0x50, 0xf5, 0x4d, 0xb8, 0xe0, 0x7d, 0xe0, 0x92, 0x47,
	0x40, 0xe5, 0x45, 0x90, 0x8f, 0xdb, 0x92, 0x89, 0xdd, 0x44, 0xf9, 0x7e, 0xec, 0xcf, 0xc7, 0x3e,
	0x07, 0x0e, 0xf3, 0xbb, 0x59, 0xc2, 0x73, 0x99, 0xd8, 0x65, 0x8e, 0xc6, 0x7f, 0xe3, 0xbc, 0xd0,
	0x56, 0xf7, 0x4f, 0x67, 0xd2, 0xde, 0x96, 0x93, 0x78, 0xaa, 0xb3, 0x64, 0xa6, 0x67, 0x3a, 0x21,
	0x7a, 0x52, 0x7e, 0x26, 0x44, 0x80, 0xfe, 0xbc, 0x3d, 0x1a, 0xc2, 0xde, 0x48, 0x5d, 0xce, 0xf9,
	0xf2, 0xcd, 0x57, 0x54, 0xd6, 0xa4, 0xf8, 0xa5, 0x44, 0x63, 0xd9, 0x13, 0xe8, 0xce, 0x91, 0xcf,
	0x4a, 0x1c, 0x4b, 0x11, 0xd6, 0x8f, 0x83, 0x93, 0x6e, 0xda, 0xf1, 0xc4, 0x48, 0x44, 0x2f, 0x60,
	0x77, 0xe3, 0x36, 0xb9, 0x56, 0x06, 0xd9, 0x00, 0x5a, 0x48, 0x4c, 0x18, 0x1c, 0x37, 0x4e, 0x7a,
	0xc3, 0x56, 0x4c, 0x86, 0x74, 0xcd, 0x46, 0x67, 0xf0, 0x98, 0x88, 0xcb, 0x02, 0x85, 0x9c, 0x5a,
	0xa9, 0xd5, 0x26, 0xe8, 0x10, 0x3a, 0xe4, 0x71, 0x39, 0x01, 0xe5, 0xb4, 0x09, 0x8f, 0x44, 0xf4,
	0x0a, 0x58, 0xd5, 0xbf, 0x8e, 0x7a, 0x0e, 0x90, 0x6f, 0x59, 0x5a, 0xd2, 0x1b, 0xf6, 0xe2, 0x8a,
	0xb1, 0x22, 0x47, 0x9f, 0x00, 0xfe, 0x29, 0x2e, 0xeb, 0x56, 0x67, 0x38, 0x5e, 0x48, 0xbf, 0x30,
	0x48, 0xdb, 0x0e, 0x5f, 0x4b, 0xc5, 0x18, 0xec, 0x88, 0x82, 0x2f, 0xa8, 0xd4, 0x20, 0xa5, 0x7f,
	0x67, 0xe7, 0x0b, 0xbe, 0x24, 0x7b, 0xc3, 0xdb, 0x1d, 0xbe, 0x96, 0x2a, 0xfa, 0x11, 0x40, 0x93,
	0x0a, 0x62, 0xbb, 0x50, 0xdf, 0x9e, 0xbc, 0x2e, 0x05, 0x3b, 0x82, 0x9e, 0x95, 0x19, 0x8e, 0x8d,
	0xe5, 0xb6, 0x34, 0xeb, 0xab, 0x03, 0x47, 0x7d, 0x24, 0x86, 0xed, 0x43, 0xd3, 0x4c, 0x75, 0x81,
	0xb4, 0x65, 0x37, 0xf5, 0xc0, 0xdd, 0x37, 0x1d, 0xcd, 0x22, 0xcf, 0xc2, 0x1d, 0x7f, 0xdf, 0x8e,
	0xb8, 0x42, 0x9e, 0x39, 0x91, 0x0e, 0x42, 0x62, 0xd3, 0x8b, 0x8e, 0x20, 0xf1, 0x08, 0x7a, 0xeb,
	0x97, 0x52, 0x3c, 0xc3, 0xb0, 0xe5, 0x03, 0x3d, 0xf5, 0x9e, 0x67, 0xc8, 0x9e, 0x42, 0xd3, 0xc5,
	0x17, 0x61, 0x9b, 0xee, 0xaa, 0x15, 0x5f, 0x39, 0x94, 0x7a, 0x32, 0xba, 0x81, 0x26, 0x61, 0x16,
	0x42, 0x3b, 0x93, 0xaa, 0xb4, 0x68, 0xa8, 0x9a, 0x46, 0xba, 0x81, 0x4e, 0x31, 0x38, 0xd5, 0x4a,
	0xf8, 0x72, 0x1a, 0xe9, 0x06, 0xb2, 0x67, 0x00, 0x5c, 0x08, 0x14, 0x63, 0xb7, 0x17, 0x15, 0xd4,
	0x48, 0xbb, 0xc4, 0xb8, 0x3d, 0x87, 0xdf, 0x03, 0xe8, 0xbc, 0x46, 0xcc, 0x3f, 0x08, 0x61, 0xd8,
	0x39, 0x1c, 0x5c, 0xa0, 0xf5, 0xbd, 0xf6, 0x56, 0x6b, 0x3b, 0xe1, 0xf3, 0xb9, 0xef, 0x22, 0xb6,
	0x1f, 0x3f, 0xd0, 0x82, 0xfd, 0x47, 0xf1, 0xfd, 0x26, 0x8b, 0x6a, 0xec, 0x1d, 0xf4, 0x2f, 0xd0,
	0xde, 0x5b, 0x5d, 0x79, 0xde, 0x83, 0xf8, 0xe1, 0x1e, 0xeb, 0xef, 0xc5, 0xff, 0xf7, 0x51, 0x54,
	0x3b, 0x7f, 0xf9, 0x73, 0x35, 0x08, 0x7e, 0xad, 0x06, 0xc1, 0xef, 0xd5, 0x20, 0xf8, 0xf6, 0x67,
	0x50, 0xbb, 0xa9, 0xce, 0x8e, 0x28, 0xb8, 0xba, 0xd3, 0x65, 0x22, 0x10, 0xf3, 0x53, 0x2d, 0x44,
	0xe2, 0x46, 0x6e, 0x82, 0xd6, 0x6c, 0xc7, 0x6e, 0xd2, 0xa2, 0x11, 0x3a, 0xfb, 0x1b, 0x00, 0x00,
	0xff, 0xff, 0xa6, 0x6c, 0xfe, 0xec, 0x8e, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DeepOddsClient is the client API for DeepOdds service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DeepOddsClient interface {
	GetInPlayFootballEvents(ctx context.Context, in *InPlayEventsRequest, opts ...grpc.CallOption) (*EventsResponse, error)
	GetFootballEventPrediction(ctx context.Context, in *EventPredictionRequest, opts ...grpc.CallOption) (*PredictionResponse, error)
}

type deepOddsClient struct {
	cc *grpc.ClientConn
}

func NewDeepOddsClient(cc *grpc.ClientConn) DeepOddsClient {
	return &deepOddsClient{cc}
}

func (c *deepOddsClient) GetInPlayFootballEvents(ctx context.Context, in *InPlayEventsRequest, opts ...grpc.CallOption) (*EventsResponse, error) {
	out := new(EventsResponse)
	err := c.cc.Invoke(ctx, "/DeepOdds/GetInPlayFootballEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deepOddsClient) GetFootballEventPrediction(ctx context.Context, in *EventPredictionRequest, opts ...grpc.CallOption) (*PredictionResponse, error) {
	out := new(PredictionResponse)
	err := c.cc.Invoke(ctx, "/DeepOdds/GetFootballEventPrediction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeepOddsServer is the server API for DeepOdds service.
type DeepOddsServer interface {
	GetInPlayFootballEvents(context.Context, *InPlayEventsRequest) (*EventsResponse, error)
	GetFootballEventPrediction(context.Context, *EventPredictionRequest) (*PredictionResponse, error)
}

// UnimplementedDeepOddsServer can be embedded to have forward compatible implementations.
type UnimplementedDeepOddsServer struct {
}

func (*UnimplementedDeepOddsServer) GetInPlayFootballEvents(ctx context.Context, req *InPlayEventsRequest) (*EventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInPlayFootballEvents not implemented")
}
func (*UnimplementedDeepOddsServer) GetFootballEventPrediction(ctx context.Context, req *EventPredictionRequest) (*PredictionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFootballEventPrediction not implemented")
}

func RegisterDeepOddsServer(s *grpc.Server, srv DeepOddsServer) {
	s.RegisterService(&_DeepOdds_serviceDesc, srv)
}

func _DeepOdds_GetInPlayFootballEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InPlayEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeepOddsServer).GetInPlayFootballEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/DeepOdds/GetInPlayFootballEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeepOddsServer).GetInPlayFootballEvents(ctx, req.(*InPlayEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeepOdds_GetFootballEventPrediction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventPredictionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeepOddsServer).GetFootballEventPrediction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/DeepOdds/GetFootballEventPrediction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeepOddsServer).GetFootballEventPrediction(ctx, req.(*EventPredictionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DeepOdds_serviceDesc = grpc.ServiceDesc{
	ServiceName: "DeepOdds",
	HandlerType: (*DeepOddsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInPlayFootballEvents",
			Handler:    _DeepOdds_GetInPlayFootballEvents_Handler,
		},
		{
			MethodName: "GetFootballEventPrediction",
			Handler:    _DeepOdds_GetFootballEventPrediction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/api/types/types.proto",
}

func (m *InPlayEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InPlayEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InPlayEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LeagueId) > 0 {
		i -= len(m.LeagueId)
		copy(dAtA[i:], m.LeagueId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LeagueId)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *EventsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventPredictionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPredictionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPredictionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PredictionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredictionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredictionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Prediction != nil {
		{
			size, err := m.Prediction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Prediction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prediction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Prediction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AwayWin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AwayWin))))
		i--
		dAtA[i] = 0x19
	}
	if m.Draw != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Draw))))
		i--
		dAtA[i] = 0x11
	}
	if m.HomeWin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.HomeWin))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timer != nil {
		{
			size, err := m.Timer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LeagueName) > 0 {
		i -= len(m.LeagueName)
		copy(dAtA[i:], m.LeagueName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LeagueName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AwayTeam) > 0 {
		i -= len(m.AwayTeam)
		copy(dAtA[i:], m.AwayTeam)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AwayTeam)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HomeTeam) > 0 {
		i -= len(m.HomeTeam)
		copy(dAtA[i:], m.HomeTeam)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HomeTeam)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Score) > 0 {
		i -= len(m.Score)
		copy(dAtA[i:], m.Score)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Score)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TimeStatus) > 0 {
		i -= len(m.TimeStatus)
		copy(dAtA[i:], m.TimeStatus)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TimeStatus)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Timer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AddedTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AddedTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Seconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x10
	}
	if m.Minutes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Minutes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InPlayEventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LeagueId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventPredictionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PredictionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prediction != nil {
		l = m.Prediction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Prediction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HomeWin != 0 {
		n += 9
	}
	if m.Draw != 0 {
		n += 9
	}
	if m.AwayWin != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TimeStatus)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Score)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HomeTeam)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AwayTeam)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LeagueName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Timer != nil {
		l = m.Timer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Timer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Minutes != 0 {
		n += 1 + sovTypes(uint64(m.Minutes))
	}
	if m.Seconds != 0 {
		n += 1 + sovTypes(uint64(m.Seconds))
	}
	if m.AddedTime != 0 {
		n += 1 + sovTypes(uint64(m.AddedTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InPlayEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InPlayEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InPlayEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeagueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeagueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPredictionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPredictionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPredictionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredictionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredictionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredictionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prediction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prediction == nil {
				m.Prediction = &Prediction{}
			}
			if err := m.Prediction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prediction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prediction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prediction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeWin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.HomeWin = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draw", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Draw = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwayWin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AwayWin = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Score = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeTeam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeTeam = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwayTeam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwayTeam = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeagueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeagueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timer == nil {
				m.Timer = &Timer{}
			}
			if err := m.Timer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minutes", wireType)
			}
			m.Minutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minutes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedTime", wireType)
			}
			m.AddedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddedTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
